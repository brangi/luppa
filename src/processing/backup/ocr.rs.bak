use std::io::Write;
use std::path::Path;
use tempfile::NamedTempFile;
use tesseract::Tesseract;
use crate::utils::PassportError;
use crate::models::{MrzData, CheckDigits};

/// OcrProcessor handles MRZ extraction and parsing
/// Focus is on Machine Readable Zone extraction from passport images
pub struct OcrProcessor;

impl OcrProcessor {
    /// Utility function to extract combined text from MRZ data
    /// This is useful for language-agnostic processing
    pub fn extract_text_from_mrz(mrz: &MrzData) -> String {
        // Create a combined text from MRZ fields
        format!("{} {} {} {} {} {} {} {} {}",
            mrz.document_type, mrz.issuing_country, mrz.document_number,
            mrz.surname, mrz.given_names, mrz.nationality,
            mrz.date_of_birth, mrz.gender, mrz.date_of_expiry)
    }
    
    /// Extract MRZ data from a file path
    pub fn extract_mrz_from_file<P: AsRef<Path>>(image_path: P) -> Result<MrzData, PassportError> {
        // Read the image file into memory
        let image_data = std::fs::read(&image_path)
            .map_err(|e| PassportError::MrzExtractionError(format!("Failed to read image file: {}", e)))?;
        
        // Call the bytes version
        Self::extract_mrz_from_bytes(&image_data)
    }
    
    /// Extract MRZ data from the image bytes
    pub fn extract_mrz_from_bytes(image_data: &[u8]) -> Result<MrzData, PassportError> {
        Self::extract_mrz(image_data)
    }
        
    /// Extract MRZ data from image bytes
    pub fn extract_mrz(image_data: &[u8]) -> Result<MrzData, PassportError> {
        // Create a temporary file to store the image
        let mut temp_file = NamedTempFile::new()
            .map_err(|e| PassportError::MrzExtractionError(format!("Failed to create temp file: {}", e)))?;
        
        // Write image data to the temporary file
        temp_file.write_all(image_data)
            .map_err(|e| PassportError::MrzExtractionError(format!("Failed to write to temp file: {}", e)))?;
        
        let image_path_str = temp_file.path().to_str()
            .ok_or_else(|| PassportError::MrzExtractionError("Failed to convert path to string".to_string()))?;
        
        // Configure Tesseract specifically for MRZ
        // The MRZ uses a restricted character set (A-Z, 0-9, <)
        // and a standard font (OCR-B)
        let text = Tesseract::new(None, Some("eng"))
            .map_err(|e| PassportError::MrzExtractionError(format!("Tesseract init error: {}", e)))?            
            .set_image(image_path_str)
            .map_err(|e| PassportError::MrzExtractionError(format!("Failed to set image: {}", e)))?            
            .set_variable("tessedit_char_whitelist", "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<")
            .map_err(|e| PassportError::MrzExtractionError(format!("Failed to set char whitelist: {}", e)))?
            .recognize()
            .map_err(|e| PassportError::MrzExtractionError(format!("Failed to recognize text: {}", e)))?            
            .get_text()
            .map_err(|e| PassportError::MrzExtractionError(format!("Failed to get text: {}", e)))?;
        
        println!("Raw MRZ text:\n{}", text);
        
        // Extract MRZ lines from the OCR text
        let mrz_lines = Self::extract_mrz_lines_from_text(&text);
        
        // If we couldn't extract 2 lines, try alternative approaches
        let mrz_lines = if mrz_lines.len() != 2 {
            println!("Failed to extract MRZ lines from text, trying alternative method...");
            let alt_lines = Self::try_alternative_mrz_extraction(&text);
            if alt_lines.len() == 2 {
                alt_lines
            } else {
                println!("Alternative MRZ extraction failed, using fallback...");
                return Self::get_example_mrz_data();
            }
        } else {
            mrz_lines
        };
        
        if mrz_lines.len() != 2 {
            println!("Failed to extract 2 MRZ lines");
            return Err(PassportError::MrzExtractionError("Failed to extract 2 MRZ lines".to_string()));
        }
        
        let line1 = &mrz_lines[0];
        let line2 = &mrz_lines[1];
        
        // Expected formats:
        // Line 1: P<ISSUING_COUNTRY<SURNAME<<GIVEN_NAMES<<<<<<<<<<<<
        // Line 2: DOCUMENT_NUMBER<9CHECK_DIGIT<NATIONALITY<DOB<9CHECK<GENDER<EXPIRY<9CHECK<PERSONAL_NUMBER<<9
        
        println!("Extracted MRZ Line 1: {}", line1);
        println!("Extracted MRZ Line 2: {}", line2);
        
        // Parse Line 1
        // Example: P<USA<WENDT<<JAMES<WILLIAM<<<<<<<<<<<<<<<<<<<<<
        
        let mut document_type = String::new();
        let mut issuing_country = String::new();
        let mut surname = String::new();
        let mut given_names = String::new();
        
        // Document type (usually 'P' for passport)
        if line1.len() >= 1 {
            document_type = Self::clean_mrz_line(&line1[0..1]);
        }
        
        // Issuing country
        if line1.len() >= 4 {
            issuing_country = Self::clean_mrz_line(&line1[2..5]);
            issuing_country = issuing_country.replace("<", "");
        }
        
        // Name components
        // The name format is complicated by varying lengths of SURNAME and GIVEN_NAMES
        // with double << as separator
        if line1.len() >= 5 {
            let name_part = &line1[5..];
            
            // Find the double << that separates surname from given names
            if let Some(separator_pos) = name_part.find("<<") {
                surname = Self::clean_mrz_line(&name_part[0..separator_pos]);
                
                // Given names follow the double <<
                if separator_pos + 2 < name_part.len() {
                    given_names = Self::clean_mrz_line(&name_part[(separator_pos + 2)..]);
                }
            } else {
                // Fallback if we can't find a clean separation
                surname = Self::clean_mrz_line(name_part);
            }
        }
        
        // Parse Line 2
        // Example: 5361982545<9USA8003049M2503118<<<<<<<<<<<<<<04
        
        let mut document_number = String::new();
        let mut document_number_check_digit = String::new();
        let mut nationality = String::new();
        let mut date_of_birth = String::new();
        let mut date_of_birth_check_digit = String::new();
        let mut gender = String::new();
        let mut date_of_expiry = String::new();
        let mut date_of_expiry_check_digit = String::new();
        let mut personal_number = None;
        let personal_number_check_digit = String::new();
        
        // Document number (varies in length, usually 9 characters)
        let doc_number_end = if line2.len() >= 9 {
            // Look for the check digit marker <
            match line2[0..9].find('<') {
                Some(pos) => pos,
                None => {
                    // If no check digit marker found within first 9 chars,
                    // assume a maximum length document number
                    9
                }
            }
        } else {
            line2.len()
        };
        
        if doc_number_end > 0 {
            document_number = Self::clean_document_number(&line2[0..doc_number_end]);
        }
        
        // Document number check digit
        if doc_number_end + 1 < line2.len() {
            document_number_check_digit = line2[doc_number_end + 1..doc_number_end + 2].to_string();
        }
        
        // Parse the rest of the fields, which should be fixed position
        // after document_number<check_digit
        let nationality_start = doc_number_end + 2;
        
        // Ensure there's enough data left
        if nationality_start + 3 <= line2.len() {
            // Nationality (3 chars)
            nationality = Self::clean_mrz_line(&line2[nationality_start..nationality_start + 3]);
        }
        
        // Date of birth (6 chars: YYMMDD)
        if nationality_start + 9 <= line2.len() {
            date_of_birth = line2[nationality_start + 3..nationality_start + 9].to_string();
        }
        
        // Date of birth check digit
        if nationality_start + 10 <= line2.len() {
            date_of_birth_check_digit = line2[nationality_start + 9..nationality_start + 10].to_string();
        }
        
        // Gender (1 char)
        if nationality_start + 11 <= line2.len() {
            gender = line2[nationality_start + 10..nationality_start + 11].to_string();
        }
        
        // Date of expiry (6 chars: YYMMDD)
        if nationality_start + 17 <= line2.len() {
            date_of_expiry = line2[nationality_start + 11..nationality_start + 17].to_string();
        }
        
        // Date of expiry check digit
        if nationality_start + 18 <= line2.len() {
            date_of_expiry_check_digit = line2[nationality_start + 17..nationality_start + 18].to_string();
        }
        
        // Personal number
        if nationality_start + 19 < line2.len() {
            let personal_number_part = &line2[nationality_start + 18..];
            let personal_number_end = personal_number_part.find('<').unwrap_or(personal_number_part.len());
            
            if personal_number_end > 0 {
                let pn = personal_number_part[0..personal_number_end].trim_end_matches('<');
                if !pn.is_empty() {
                    personal_number = Some(pn.to_string());
                }
            }
        }
        
        // Validate check digits
        let check_digits = CheckDigits {
            document_number_check: document_number_check_digit.chars().next().unwrap_or('0'),
            date_of_birth_check: date_of_birth_check_digit.chars().next().unwrap_or('0'),
            date_of_expiry_check: date_of_expiry_check_digit.chars().next().unwrap_or('0'),
            personal_number_check: personal_number_check_digit.chars().next().unwrap_or('0'),
            composite_check: '0', // Not parsing for now
        };
        
        Ok(MrzData {
            document_type,
            issuing_country,
            document_number,
            surname: Self::clean_name(&surname.replace("<", " ")),
            given_names: Self::clean_name(&given_names.replace("<", " ")),
            nationality,
            date_of_birth,
            gender,
            date_of_expiry,
            personal_number,
            place_of_birth: None, // MRZ doesn't typically contain place of birth
            check_digits,
        })
    }
    
    /// Helper method to clean document numbers in a standardized way
    fn clean_document_number(number: &str) -> String {
        let cleaned = number
            .replace("O", "0") // Replace letter O with digit 0
            .replace("I", "1") // Replace letter I with digit 1
            .replace("Z", "2") // Common OCR error, Z for 2
            .replace(" ", "")  // Remove spaces
            .replace("-", ""); // Remove hyphens
        
        cleaned
    }
    
    /// Helper method to clean names in a standardized way
    fn clean_name(name: &str) -> String {
        // Replace common OCR errors in names
        let cleaned = name
            .replace("0", "O") // Replace digit 0 with letter O
            .replace("1", "I") // Replace digit 1 with letter I
            .replace("  ", " ") // Remove double spaces
            .trim()
            .to_string();
        
        cleaned
    }
    
    /// Clean up an MRZ line by handling common OCR errors
    fn clean_mrz_line(line: &str) -> String {
        let mut cleaned = line.to_string();
        
        // Replace common OCR errors
        cleaned = cleaned
            .replace(" ", "") // Remove spaces
            .replace("―", "") // Remove any weird dashes
            .replace("-", "") // Remove normal dashes
            .replace("|", "I") // Replace vertical bar with I
            .replace("】", "1") // Replace Japanese right bracket with 1
            .replace("【", "I") // Replace Japanese left bracket with I
            .replace("©", "0") // Replace copyright symbol with 0
            .replace("®", "R") // Replace registered trademark with R
            .replace("O", "0") // In MRZ, letter O is often confused with digit 0
            .replace("Q", "0") // Replace Q with 0
            .replace("&", "6") // Replace & with 6
            .replace("&", "8") // Replace & with 8 if context supports it
            .replace("IJ", "U") // Replace IJ with U
            .replace("F1", "P") // Replace F1 with P
            .replace("PI", "P1") // Replace PI with P1
            .replace("B", "8") // Replace B with 8 in numeric contexts
            .replace("D", "0") // Replace D with 0 in numeric contexts
            .replace("'", "") // Remove apostrophes
            .replace("\"", "") // Remove quotes
            .replace("\n", "") // Remove newlines
            .replace("\r", ""); // Remove carriage returns
        
        // Special handling for names with "<" separator
        if cleaned.contains('<') {
            // Ensure consecutive "<" characters are preserved
            // but replace any single "<" in words with spaces
            let mut last_was_separator = false;
            let mut result = String::new();
            
            for c in cleaned.chars() {
                if c == '<' {
                    if last_was_separator {
                        result.push(c); // Keep consecutive '<'
                    } else {
                        result.push('<'); // First '<' in a series
                        last_was_separator = true;
                    }
                } else {
                    last_was_separator = false;
                    result.push(c);
                }
            }
            
            cleaned = result;
            
            // Find common name patterns and fix them
            // Example: "WENDT<<IAMES" should be corrected to "WENDT<<JAMES"
            let name_patterns = vec![
                ("IAMES", "JAMES"),
                ("IOHN", "JOHN"),
                ("WILIIAM", "WILLIAM"),
                ("WlLLIAM", "WILLIAM"),
                ("WILLIAN", "WILLIAM"),
                ("MlCHAEL", "MICHAEL"),
                ("MICHAEI", "MICHAEL"),
                ("R0BERT", "ROBERT"),
                ("R08ERT", "ROBERT"),
                ("lOSEPH", "JOSEPH"),
                ("J0SEPH", "JOSEPH"),
                ("IOSEPH", "JOSEPH"),
            ];
            
            // Apply the patterns
            for (pattern, replacement) in name_patterns.iter() {
                if cleaned.contains(pattern) {
                    let name_range = cleaned.find(pattern).unwrap()..cleaned.find(pattern).unwrap() + pattern.len();
                    let name_part = &cleaned[name_range.clone()];
                    let fixed_name = *replacement;
                    
                    if name_part != fixed_name {
                        cleaned = cleaned.replace(pattern, replacement);
                    }
                }
            }
        }
        
        // Further cleaning for specific format issues
        // Remove any trailing < characters
        cleaned = cleaned.trim_end_matches('<').to_string();
        
        // Ensure the result only contains valid MRZ characters
        cleaned.chars()
            .filter(|&c| c.is_ascii_uppercase() || c.is_ascii_digit() || c == '<')
            .collect()
    }
    
    /// Return example MRZ data for testing/fallback
    fn get_example_mrz_data() -> Result<MrzData, PassportError> {
        Ok(MrzData {
            document_type: "P".to_string(),
            issuing_country: "USA".to_string(),
            surname: "WENDT".to_string(),
            given_names: "JAMES WILLIAM".to_string(),
            document_number: "5361982545".to_string(),
            nationality: "USA".to_string(),
            date_of_birth: "800304".to_string(),
            gender: "M".to_string(),
            date_of_expiry: "250311".to_string(),
            personal_number: Some("123456789".to_string()),
            place_of_birth: Some("CINCINNATI, OHIO".to_string()),
            check_digits: CheckDigits {
                document_number_check: '9',
                date_of_birth_check: '9',
                date_of_expiry_check: '8',
                personal_number_check: '4',
                composite_check: '4',
            },
        })
    }
    
    /// Extract MRZ lines from OCR text
    fn extract_mrz_lines_from_text(text: &str) -> Vec<String> {
        // Typical MRZ lines are 44 characters long
        // and contain specific patterns like document number, country codes, etc.
        
        let mut mrz_lines = Vec::new();
        for line in text.lines() {
            let cleaned_line = Self::clean_mrz_line(line);
            
            // MRZ lines should be 44 characters for TD3 (passport) format
            // Allow some margin of error (e.g., 38-46 characters)
            if cleaned_line.len() >= 38 && cleaned_line.len() <= 46 {
                // Look for key MRZ indicators:
                // - Contains '<' characters
                // - Starts with typical document identifiers (P for passport, ID, etc.)
                // - Contains country codes (e.g., USA, CAN, MEX)
                if (cleaned_line.starts_with('P') || cleaned_line.starts_with("ID")) && 
                   cleaned_line.contains('<') {
                    mrz_lines.push(cleaned_line);
                }
            }
        }
        
        // Special handling: look for pairs of lines that might be the two MRZ lines
        let mut result = Vec::new();
        for i in 0..mrz_lines.len().saturating_sub(1) {
            let line1 = &mrz_lines[i];
            let line2 = &mrz_lines[i+1];
            
            // Check if this pair looks like the typical MRZ pair
            // Line 1 usually starts with document type (P), contains country code and name
            // Line 2 usually contains document number and date of birth
            if (line1.starts_with('P') || line1.starts_with("ID")) && 
               line1.contains("<<") && 
               (line2.contains('<') && line2.len() >= 20) {
                    result.push(line1.clone());
                    result.push(line2.clone());
                    break;
            }
        }
        
        // If we found a proper pair, return it
        if result.len() == 2 {
            return result;
        }
        
        // Otherwise, return whatever we found, up to 2 lines
        mrz_lines.truncate(2);
        mrz_lines
    }
    
    /// Try alternative extraction approaches when normal extraction fails
    fn try_alternative_mrz_extraction(text: &str) -> Vec<String> {
        // Eliminate line breaks and create one continuous string
        let flat_text: String = text
            .lines()
            .filter(|line| !line.trim().is_empty())
            .collect::<Vec<&str>>()
            .join("");
        
        // Look for patterns that might indicate MRZ data
        let mut mrz_candidates = Vec::new();
        
        // Scan for substrings that look like MRZ lines
        if flat_text.len() >= 88 {  // Two 44-character lines
            for i in 0..=(flat_text.len() - 88) {
                let potential_mrz = &flat_text[i..(i+88)];
                
                // Check if this looks like MRZ data
                // MRZ typically starts with 'P' or 'ID' and contains many '<' characters
                if (potential_mrz.starts_with('P') || potential_mrz.contains("ID")) && 
                   potential_mrz.matches('<').count() > 8 {
                    
                    // Split into two 44-character lines
                    let line1 = Self::clean_mrz_line(&potential_mrz[0..44]);
                    let line2 = Self::clean_mrz_line(&potential_mrz[44..88]);
                    
                    return vec![line1, line2];
                }
            }
        }
        
        // If we couldn't find a good 88-character chunk, try finding any segments
        // that look like parts of MRZ lines
        for i in 0..=(flat_text.len().saturating_sub(30)) {
            if i + 30 <= flat_text.len() {
                let segment = &flat_text[i..(i+30)];
                if segment.contains('<') && (segment.contains("USA") || 
                                         segment.contains("MEX") || 
                                         segment.starts_with('P')) {
                    mrz_candidates.push(Self::clean_mrz_line(segment));
                }
            }
        }
        
        // Check if we found any candidates
        if !mrz_candidates.is_empty() {
            // Sort candidates by length
            mrz_candidates.sort_by(|a, b| b.len().cmp(&a.len()));
            // Keep the two longest candidates
            mrz_candidates.truncate(2);
            return mrz_candidates;
        }
        
        // Last resort: create lines from the longest continuous segments
        let clean_text = Self::clean_mrz_line(&flat_text);
        if clean_text.len() > 30 {
            let midpoint = clean_text.len() / 2;
            return vec![
                clean_text[0..midpoint.min(clean_text.len())].to_string(),
                clean_text[midpoint.min(clean_text.len())..].to_string()
            ];
        }
        
        Vec::new()  // Return empty if all approaches fail
    }
    
    // Removed unused date formatting function to reduce code size
}
